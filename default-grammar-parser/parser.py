#
# CPSC 323 Parser Project
# Author: Nicholas Ayson, Ehtan Stupin
# Your task is to implement a parser using the default grammar 
# parser csv table generated by the Java program.
#
class Parser:
    """
    This class parses the token stream outputted from the lexical analyzer 
    into a parse tree or produces errors if the program is malformed.
    """
    def __init__(self, token_stream, parse_table_file):
        """
        Class constructor takes the token stream output from the 
        lexical analyzer as input. Appends $ to the end of the stream.
        """
        self.token_stream = token_stream
        self.parser_table = self.__read_parse_table(parse_table_file)
        # Append the end of file symbol to the end.
        self.token_stream.append(("$", "$"))

    def __read_parse_table(self, parse_table_file):
        """
        Reads the parse table from a file.
        @param parse_table_file The file path for the parse table csv file.
        @return A dictionary/map (state, symbol) -> action/goto.
        """
        self.token_stream.append(0)
        # line1data = rows[0].rstrip().split(',')
        
        # table_string = read_file_as_string(parse_table_file)
        # rows = table_string.split('\n')
        parse_table = {}
        for i in range(0,10):
            # line_tuple = parse_table.split(',')
            state = int(self.token_stream[0])
            token = str(self.token_stream[1])
            x = parse_table[state, token]
            match x:
                case ['S', i]:
                    parse_table.append(i)
                    parse_table.append(state)
                case ['R', i]:
                    L = i + 1
                    parse_table.pop(L)
                    Qj = state
                    parse_table.append(L)
                    parse_table.append(parse_table[Qj, L])
                case ["ACCT", i]:
                    print("Parsing is complete")
                case None:
                    print("Error in parsing")
        return parse_table

    def __has_next_token(self):
        """
        @return True if the token stream is not empty.
        """
        return len(self.token_stream) != 0

    def __get_next_token(self):
        """
        Fetches and consumes the next token in the input.
        @return tuple (token, type)
        """
        if self.__has_next_token():
            to_return = self.token_stream[0]
            print(self.token_stream[1])
            print("line 70")
            self.token_stream.pop(0)
            return to_return
        return None

    def parse(self):
        print(self.__get_next_token())
        """self.token_stream.push(0)"""
        return(self.__read_parse_table())
        # raise NotImplementedError()