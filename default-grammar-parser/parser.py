#
# CPSC 323 Parser Project
# Author: Nicholas Ayson, Ehtan Stupin
# Your task is to implement a parser using the default grammar 
# parser csv table generated by the Java program.
#
class Parser:
    """
    This class parses the token stream outputted from the lexical analyzer 
    into a parse tree or produces errors if the program is malformed.
    """
    def __init__(self, token_stream, parse_table_file):
        """
        Class constructor takes the token stream output from the 
        lexical analyzer as input. Appends $ to the end of the stream.
        """
        self.token_stream = token_stream
        self.parser_table = self.__read_parse_table(parse_table_file)
        # Append the end of file symbol to the end.
        self.token_stream.append(("$", "$"))

    def __read_parse_table(self, parse_table_file):
        """
        Reads the parse table from a file.
        @param parse_table_file The file path for the parse table csv file.
        @return A dictionary/map (state, symbol) -> action/goto.
        """
        self.token_stream.append(0)
        table_string = self.__read_file_as_string(parse_table_file)
        rows = table_string.split('\n')
        # line1data = rows[0].rstrip().split(',')
        # print(line1data)
        parse_table = {}
        for i in range(0,len(rows)):
        # while self.token_stream is not None:
            # line_tuple = rows[i].split(',')
            # state = line_tuple[0]
            # print("state " + state)
            # token = line1data[i]
            # print("token " + token)
            state = i
            print(i)
            token = self.__get_next_token()
            print(token)
            x = parse_table[state, token]
            match x:
                case ['S', i]:
                    x.append(i)
                    x.append(state)
                case ['R', i]:
                    L = i + 1
                    x.pop(L)
                    Qj = state
                    x.append(L)
                    x.append(parse_table[Qj, L])
                case ["ACCT", i]:
                    print("Parsing is complete")
                case None:
                    print("Error in parsing")
        return x
        # raise NotImplementedError()

    def __has_next_token(self):
        """
        @return True if the token stream is not empty.
        """
        return len(self.token_stream) != 0

    def __get_next_token(self):
        """
        Fetches and consumes the next token in the input.
        @return tuple (token, type)
        """
        if self.__has_next_token():
            to_return = self.token_stream[0]
            self.token_stream.pop(0)
            return to_return
        return None

    def parse(self):
        print(self.__get_next_token())
        """self.token_stream.push(0)"""
        # return(self.__read_parse_table(self.parser_table))
        # raise NotImplementedError()
    
    def __read_file_as_string(self, parse_table_file):
        """
        Reads the provided file as a string.
        @param filename: Name of the file to read.
        @return: A string of the files contents.
        """
        with open(parse_table_file, 'r') as file_pointer:
            return file_pointer.read()
        
        
# token = next_token()

# repeat forever
#    s = top of stack
   
#    if action[s, token] = “shift si” then
#       PUSH token
#       PUSH si 
#       token = next_token()
      
#    else if action[s, token] = “reduce A::= β“ then 
#       POP 2 * |β| symbols
#       s = top of stack
#       PUSH A
#       PUSH goto[s,A]
      
#    else if action[s, token] = “accept” then
#       return
      
#    else
#       error()