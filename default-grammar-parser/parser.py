#
# CPSC 323 Parser Project
# Author: Nicholas Ayson, Ehtan Stupin
# Your task is to implement a parser using the default grammar 
# parser csv table generated by the Java program.
#

# Be sure to show the stack, input, and action performed for each step of the parsing. 
# If there is an error, terminate the parsing and display a useful error message along with what tokens would have been accepted for a valid parsing. 
# Paste the results of the parsing into a text file.
# from lexer import Lexer, __get_token

from csv import reader
from secrets import token_urlsafe
from lexer import Lexer

SHIFT = 1
REDUCE = 2
STOP = 3
ACCEPT = 4

PRODUCTIONS = {
    1:"S -> E = E",
    2:"S -> id",
    3:"E -> E + id",
    4:"E -> id",
}

def get_action(act: str):
    '''
    A simple function to return action along with required information
    (Example: Which production to use or Which state to shift).
    '''
    if not act:
        return (STOP, None)
    elif act == 'ACCT':
        return (ACCEPT, None)
    elif act[0] == 'R':
        return (REDUCE, int(act.lstrip('R')))
    elif act[0] == 'S':
        return (SHIFT, int(act.lstrip('S')))
    
class Parser:
    """
    This class parses the token stream outputted from the lexical analyzer 
    into a parse tree or produces errors if the program is malformed.
    """
    def __init__(self, token_stream, parse_table_file, source_code):
        """
        Class constructor takes the token stream output from the 
        lexical analyzer as input. Appends $ to the end of the stream.
        """
        self.token_stream = token_stream
        self.source_code = source_code + " "
        self.parser_table = self.__read_parse_table(parse_table_file)
        # Append the end of file symbol to the end.
        self.token_stream.append(("$", "$"))
        
        

    def __read_parse_table(self, parse_table_file):
        """
        Reads the parse table from a file.
        @param parse_table_file The file path for the parse table csv file.
        @return A dictionary/map (state, symbol) -> action/goto.
        """
        # This will print out everything inside the source code with ids
        self.action = dict()
        self.goto = dict()
        with open('parse_table.csv') as f:
            csv = reader(f)
            symbols = dict()    
            for row in csv:
                # this will enumerate all of the symbols into symbols dict
                if row[0] == 'State':
                    for i, sym in enumerate(row[1:], start=1):
                        symbols[i] = sym
                else:
                    # checks if states are equal to integers now
                    state = int(row[0])
                    
                    for i, act in enumerate(row[1:], start=1):
                        sym = symbols[i]
                        if sym.isupper():
                            self.goto[(state, sym)] = int(act) if act else None
                        else:
                        # calls the get action function and returns stop, accept, reduce or shift
                            self.action[(state, sym)] = get_action(act)
        # raise NotImplementedError()

    def __has_next_token(self):
        """
        @return True if the token stream is not empty.
        """
        return len(self.token_stream) != 0

    def __get_next_token(self):
        """
        Fetches and consumes the next token in the input.
        @return tuple (token, type)
        """
        if self.__has_next_token():
            to_return = self.token_stream[0]
            self.token_stream.pop(0)
            return to_return
        return None

    def parse(self):
        print("(State, Symbol)")
        print(self.token_stream)
        # tokens = self.token_stream
        # individual_token = tokens[0]
        # # checks inside the token stream for indivual token
        # print("individual token = " + individual_token[0])
        
        self.states = [0]
        self.symbols = [('$')]
        tokens = self.token_stream # Creates a list of all the tokens from the input.
        i=0

        while True:
            # Quit if tokens are over and string has not been accepted.
            if i>len(tokens):
                print("Stop")
                return

            individual_token  = tokens[i]

            # Get Action
            state = self.states[-1]
            action = self.action[(state, individual_token[1])]
            print("\nStack: ",self.states)
            print("Input: ", self.symbols)

            # Action related Logic
            if action[0] == ACCEPT:
                print("Accept")
                return
            elif action[0] == STOP:
                print("Stop")
                return
            elif action[0] == SHIFT:
                print("Shift State ", action[1])
                self.states.append(action[1])
                self.symbols.append(individual_token)
                i=i+1
                continue
            elif action[0] == REDUCE:
                print("Reduce Using Production Number: ", action[1])
                self.reduce_action(action)
            else:
                print("There was an error that occured. Please check your grammar")
    
        
        # raise NotImplementedError()
    def reduce_action(self, action):
        '''
        Function to implement reduce logic along with attribute calculations.
        '''
        prod_len = len(PRODUCTIONS[action[1]]) - 3 # Length of RHS
        prod_lhs = PRODUCTIONS[action[1]][0]
        popped = []
        # for i in range(prod_len):
        # print(prod_len)
        if(action[1] == 3): 
            print("Production Step: E -> E + id" )
            self.states.pop(-1)
            self.states.pop(-1)
            self.states.pop(-1)
            popped.insert(0, self.symbols.pop(-1))
            popped.insert(0, self.symbols.pop(-1))
            popped.insert(0, self.symbols.pop(-1))
            self.symbols.append(prod_lhs)
            
            self.states.append(9)
        
        if(action[1] == 1):
            print("Production Step: S -> E = E" )
            self.states.pop(-1)
            self.states.pop(-1)
            self.states.pop(-1)
            popped.insert(0, self.symbols.pop(-1))
            popped.insert(0, self.symbols.pop(-1))
            popped.insert(0, self.symbols.pop(-1))
            
            self.states.append(1)
            
        if(action[1] == 4):
            print("Production Step: E -> id") 
            
        
        if(action[1] == 2):
            print("Production Step: S -> id") 
      
        self.states.pop(-1)
        popped.insert(0, self.symbols.pop(-1))
        
        
        self.symbols.append((prod_lhs))
        print('Next State', self.goto[(self.states[-1], prod_lhs)])
        self.states.append(self.goto[(self.states[-1], prod_lhs)])